---
import Layout from '../layouts/Layout.astro';
import companiesData from '../data/companies.json';

const companies = companiesData.companies;

// Calculate statistics
const publicCount = companies.filter(c => c.type === 'public').length;
const privateCount = companies.filter(c => c.type === 'private').length;
const countries = [...new Set(companies.map(c => c.country))];

// Format currency
function formatValuation(value: number | null): string {
  if (!value) return '—';
  if (value >= 1e12) return `$${(value / 1e12).toFixed(2)}T`;
  if (value >= 1e9) return `$${(value / 1e9).toFixed(2)}B`;
  if (value >= 1e6) return `$${(value / 1e6).toFixed(0)}M`;
  return `$${value.toLocaleString()}`;
}

// Calculate total private valuation
const totalPrivateValuation = companies
  .filter(c => c.type === 'private' && c.valuationManual)
  .reduce((sum, c) => sum + (c.valuationManual || 0), 0);

// SEO metadata
const siteUrl = "https://robotico-portal.netlify.app";
const pageTitle = "Industry Overview | Robotico";
const pageDescription = `Explore the humanoid robotics industry with ${companies.length} companies across ${countries.length} countries. View market trends, valuations, and growth metrics.`;
const pageKeywords = "humanoid robotics industry, robotics market cap, humanoid robot companies, robotics market share, robotics industry trends";

const industryStructuredData = {
  "@context": "https://schema.org",
  "@type": "WebPage",
  "name": pageTitle,
  "description": pageDescription,
  "url": `${siteUrl}/industry`,
  "breadcrumb": {
    "@type": "BreadcrumbList",
    "itemListElement": [
      {
        "@type": "ListItem",
        "position": 1,
        "name": "Home",
        "item": siteUrl
      },
      {
        "@type": "ListItem",
        "position": 2,
        "name": "Industry",
        "item": `${siteUrl}/industry`
      }
    ]
  }
};
---

<Layout
  title={pageTitle}
  description={pageDescription}
  keywords={pageKeywords}
  canonicalUrl={`${siteUrl}/industry`}
  structuredData={industryStructuredData}
>
  <!-- Full-screen globe background -->
  <div class="globe-background" id="globe-container">
    <div class="globe-loading" id="globe-loading">
      <div class="loading-spinner"></div>
      <span>Loading globe...</span>
    </div>
    <div class="globe-overlay"></div>
  </div>

  <!-- Company tooltip for globe interaction -->
  <div class="company-tooltip" id="company-tooltip">
    <div class="tooltip-content">
      <div class="tooltip-header">
        <img id="tooltip-logo" src="" alt="" class="tooltip-logo" />
        <div class="tooltip-info">
          <h3 id="tooltip-name"></h3>
          <span id="tooltip-robot"></span>
        </div>
      </div>
      <div class="tooltip-details">
        <span id="tooltip-location"></span>
        <span id="tooltip-valuation"></span>
      </div>
    </div>
  </div>

  <div class="page-content">
    <!-- Hero Section -->
    <section class="hero industry-hero">
      <div class="hero-content">
        <div class="hero-text">
          <span class="hero-label">Global Presence</span>
          <h1>Industry<br>Overview</h1>
          <p>Explore {companies.length} humanoid robotics companies across {countries.length} countries</p>
        </div>
      </div>
    </section>

    <!-- Industry Content - Same structure as homepage table -->
    <div class="table-section">
      <div class="table-container">
        <!-- Key Metrics Header -->
        <div class="metrics-header">
          <div class="metric-item highlight">
            <span class="metric-value" id="total-industry-cap">—</span>
            <span class="metric-label">Total Industry Valuation</span>
          </div>
          <div class="metric-item">
            <span class="metric-value" id="yoy-growth">—</span>
            <span class="metric-label">Growth (6 Months)</span>
          </div>
          <div class="metric-item">
            <span class="metric-value">{companies.length}</span>
            <span class="metric-label">Companies Tracked</span>
          </div>
          <div class="metric-item">
            <span class="metric-value">{countries.length}</span>
            <span class="metric-label">Countries</span>
          </div>
        </div>

        <div class="industry-charts">

        <!-- Industry Growth Chart -->
        <section class="chart-section">
          <div class="section-header">
            <h2>Industry Growth</h2>
            <p>Total market capitalization over time</p>
          </div>
          <div class="chart-container large">
            <canvas id="industry-chart"></canvas>
          </div>
        </section>

        <!-- Market Share -->
        <section class="chart-section">
          <div class="section-header">
            <h2>Market Share by Company</h2>
            <p>Top companies by valuation</p>
          </div>
          <div class="chart-container">
            <canvas id="market-share-chart"></canvas>
          </div>
        </section>

        <!-- Breakdown Stats -->
        <section class="breakdown-section">
          <div class="breakdown-grid">
            <div class="breakdown-card">
              <h3>By Company Type</h3>
              <div class="breakdown-items">
                <div class="breakdown-item">
                  <span class="breakdown-label">
                    <span class="dot public"></span>
                    Public Companies
                  </span>
                  <span class="breakdown-value">{publicCount}</span>
                </div>
                <div class="breakdown-item">
                  <span class="breakdown-label">
                    <span class="dot private"></span>
                    Private Companies
                  </span>
                  <span class="breakdown-value">{privateCount}</span>
                </div>
              </div>
            </div>

            <div class="breakdown-card">
              <h3>By Region</h3>
              <div class="breakdown-items">
                {countries.map(country => {
                  const count = companies.filter(c => c.country === country).length;
                  return (
                    <div class="breakdown-item">
                      <span class="breakdown-label">{country}</span>
                      <span class="breakdown-value">{count}</span>
                    </div>
                  );
                })}
              </div>
            </div>

            <div class="breakdown-card">
              <h3>Private Company Valuations</h3>
              <div class="breakdown-items">
                <div class="breakdown-item">
                  <span class="breakdown-label">Total Private Valuation</span>
                  <span class="breakdown-value">{formatValuation(totalPrivateValuation)}</span>
                </div>
                <div class="breakdown-item">
                  <span class="breakdown-label">Average Valuation</span>
                  <span class="breakdown-value">{formatValuation(totalPrivateValuation / privateCount)}</span>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Company Type Distribution -->
        <section class="chart-section">
          <div class="section-header">
            <h2>Valuation Distribution</h2>
            <p>Public vs Private companies</p>
          </div>
          <div class="chart-container small">
            <canvas id="type-distribution-chart"></canvas>
          </div>
        </section>

        </div>
      </div>
    </div>
  </div>
</Layout>

<script id="companies-data" type="application/json" set:html={JSON.stringify(companies)}></script>

<script>
  // Initialize Three.js globe
  const script = document.createElement('script');
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
  script.onload = initGlobe;
  document.head.appendChild(script);

  function initGlobe() {
    const companiesRaw = document.getElementById('companies-data')?.textContent;
    if (!companiesRaw) return;

    const companiesData = JSON.parse(companiesRaw);
    const container = document.getElementById('globe-container');
    const loading = document.getElementById('globe-loading');
    const tooltip = document.getElementById('company-tooltip');

    if (!container) return;

    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.2, 2.2);  // Move camera up to show top of globe
    camera.lookAt(0, 0, 0);  // Look at center of globe

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // Check theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';

    // Globe with earth texture
    const globeGeometry = new THREE.SphereGeometry(1, 64, 64);
    const textureLoader = new THREE.TextureLoader();

    // Load earth topology texture
    const earthTexture = textureLoader.load(
      'https://unpkg.com/three-globe@2.31.0/example/img/earth-topology.png'
    );

    // Main globe with texture
    const globeMaterial = new THREE.MeshBasicMaterial({
      map: earthTexture
    });
    const texturedGlobe = new THREE.Mesh(globeGeometry, globeMaterial);
    scene.add(texturedGlobe);

    // Atmosphere glow
    const atmosphereGeometry = new THREE.SphereGeometry(1.02, 64, 64);
    const atmosphereMaterial = new THREE.MeshBasicMaterial({
      color: 0x1ED612,
      transparent: true,
      opacity: 0.05,
      side: THREE.BackSide
    });
    const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
    scene.add(atmosphere);

    // Subtle wireframe overlay
    const wireframeMaterial = new THREE.MeshBasicMaterial({
      color: 0x1ED612,
      wireframe: true,
      transparent: true,
      opacity: 0.03
    });
    const wireframeGlobe = new THREE.Mesh(new THREE.SphereGeometry(1.005, 32, 32), wireframeMaterial);
    scene.add(wireframeGlobe);

    // Company markers
    const markers = [];
    const markerGroup = new THREE.Group();

    companiesData.forEach((company) => {
      if (!company.coordinates) return;

      const { lat, lng } = company.coordinates;
      const position = latLngToVector3(lat, lng, 1.02);

      // Marker
      const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({
        color: company.type === 'public' ? 0x1ED612 : 0xffffff
      });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      marker.position.copy(position);
      marker.userData = company;
      markerGroup.add(marker);
      markers.push(marker);

      // Pulse ring for public companies
      if (company.type === 'public') {
        const ringGeometry = new THREE.RingGeometry(0.025, 0.035, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: 0x1ED612,
          transparent: true,
          opacity: 0.5,
          side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(position);
        ring.lookAt(0, 0, 0);
        ring.userData = { isPulse: true, baseScale: 1 };
        markerGroup.add(ring);
      }
    });

    scene.add(markerGroup);

    // Convert lat/lng to 3D position
    function latLngToVector3(lat, lng, radius) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      return new THREE.Vector3(
        -radius * Math.sin(phi) * Math.cos(theta),
        radius * Math.cos(phi),
        radius * Math.sin(phi) * Math.sin(theta)
      );
    }

    // Raycaster for interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let hoveredMarker = null;

    document.addEventListener('mousemove', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(markers);

      if (intersects.length > 0) {
        const marker = intersects[0].object;
        if (hoveredMarker !== marker) {
          hoveredMarker = marker;
          showTooltip(marker.userData, event.clientX, event.clientY);
          document.body.style.cursor = 'pointer';
        }
      } else {
        if (hoveredMarker) {
          hoveredMarker = null;
          hideTooltip();
          document.body.style.cursor = '';
        }
      }
    });

    document.addEventListener('click', () => {
      if (hoveredMarker) {
        window.location.href = `/company/${hoveredMarker.userData.id}`;
      }
    });

    // Companies with SVG logos
    const svgLogos = ['neura-robotics'];
    function getLogoPath(companyId) {
      return `/logos/${companyId}.${svgLogos.includes(companyId) ? 'svg' : 'ico'}`;
    }

    // Tooltip functions
    function showTooltip(company, x, y) {
      document.getElementById('tooltip-logo').src = getLogoPath(company.id);
      document.getElementById('tooltip-name').textContent = company.name;
      document.getElementById('tooltip-robot').textContent = company.flagshipRobot;
      document.getElementById('tooltip-location').textContent = company.headquarters;

      let valuation = 'Private';
      if (company.valuationManual) {
        valuation = formatValuationGlobe(company.valuationManual);
      } else if (company.type === 'public') {
        valuation = 'Public';
      }
      document.getElementById('tooltip-valuation').textContent = valuation;

      tooltip.style.left = `${x + 15}px`;
      tooltip.style.top = `${y - 20}px`;
      tooltip.classList.add('visible');
    }

    function hideTooltip() {
      tooltip.classList.remove('visible');
    }

    function formatValuationGlobe(value) {
      if (value >= 1e12) return `$${(value / 1e12).toFixed(2)}T`;
      if (value >= 1e9) return `$${(value / 1e9).toFixed(2)}B`;
      if (value >= 1e6) return `$${(value / 1e6).toFixed(0)}M`;
      return `$${value.toLocaleString()}`;
    }

    // Mouse drag rotation
    let isDragging = false;
    let previousMousePosition = { x: 0, y: 0 };
    let rotationVelocity = { x: 0, y: 0 };

    document.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    document.addEventListener('mouseup', () => {
      isDragging = false;
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const deltaX = e.clientX - previousMousePosition.x;
      const deltaY = e.clientY - previousMousePosition.y;

      rotationVelocity.x = deltaY * 0.005;
      rotationVelocity.y = deltaX * 0.005;

      previousMousePosition = { x: e.clientX, y: e.clientY };
    });

    // Animation
    let time = 0;
    function animate() {
      requestAnimationFrame(animate);
      time += 0.01;

      // Auto rotation when not dragging (slow rotation)
      if (!isDragging) {
        markerGroup.rotation.y += 0.0003;
        wireframeGlobe.rotation.y += 0.0003;
        texturedGlobe.rotation.y += 0.0003;

        // Apply velocity decay
        rotationVelocity.x *= 0.95;
        rotationVelocity.y *= 0.95;
      }

      // Apply drag rotation
      markerGroup.rotation.y += rotationVelocity.y;
      markerGroup.rotation.x += rotationVelocity.x;
      wireframeGlobe.rotation.y += rotationVelocity.y;
      wireframeGlobe.rotation.x += rotationVelocity.x;
      texturedGlobe.rotation.y += rotationVelocity.y;
      texturedGlobe.rotation.x += rotationVelocity.x;

      // Pulse animation for rings
      markerGroup.children.forEach(child => {
        if (child.userData?.isPulse) {
          const scale = 1 + Math.sin(time * 2) * 0.3;
          child.scale.set(scale, scale, scale);
          child.material.opacity = 0.5 - Math.sin(time * 2) * 0.3;
        }
      });

      renderer.render(scene, camera);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Hide loading, start animation
    loading.style.display = 'none';
    animate();
  }

  // Initialize industry charts
  function initIndustryCharts() {
    const companiesRaw = document.getElementById('companies-data')?.textContent;
    if (!companiesRaw) return;

    const companiesData = JSON.parse(companiesRaw);

    // Aggregate valuation history by date, tracking company count
    const dateMap = new Map<string, { total: number; count: number }>();
    companiesData.forEach((company: any) => {
      if (company.valuationHistory) {
        company.valuationHistory.forEach((entry: any) => {
          const current = dateMap.get(entry.date) || { total: 0, count: 0 };
          current.total += entry.value;
          current.count += 1;
          dateMap.set(entry.date, current);
        });
      }
    });

    // Filter to only include dates with at least 5 companies reporting
    const minCompanies = 5;
    const filteredDates = Array.from(dateMap.entries())
      .filter(([_, data]) => data.count >= minCompanies)
      .sort((a, b) => a[0].localeCompare(b[0]));

    const chartLabels = filteredDates.map(([d]) => {
      const [year, month] = d.split('-');
      return `${month}/${year.slice(2)}`;
    });
    const chartValues = filteredDates.map(([_, data]) => data.total / 1e9);

    // Calculate growth
    const latestValue = chartValues[chartValues.length - 1] || 0;
    const sixMonthsAgoIndex = Math.max(0, chartValues.length - 3);
    const sixMonthsAgoValue = chartValues[sixMonthsAgoIndex] || latestValue;
    const growth = sixMonthsAgoValue > 0 ? ((latestValue - sixMonthsAgoValue) / sixMonthsAgoValue * 100) : 0;

    // Update stats
    const totalCapEl = document.getElementById('total-industry-cap');
    const growthEl = document.getElementById('yoy-growth');
    if (totalCapEl) totalCapEl.textContent = `$${latestValue.toFixed(0)}B`;
    if (growthEl) {
      growthEl.textContent = `${growth >= 0 ? '+' : ''}${growth.toFixed(1)}%`;
      growthEl.classList.add(growth >= 0 ? 'positive' : 'negative');
    }

    // Check theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const gridColor = isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
    const textColor = isDark ? 'rgba(255, 255, 255, 0.7)' : 'rgba(0, 0, 0, 0.7)';

    // Industry Growth Chart
    const industryCtx = document.getElementById('industry-chart') as HTMLCanvasElement;
    if (industryCtx) {
      new (window as any).Chart(industryCtx, {
        type: 'line',
        data: {
          labels: chartLabels,
          datasets: [{
            label: 'Total Market Cap ($B)',
            data: chartValues,
            borderColor: '#1ED612',
            backgroundColor: 'rgba(30, 214, 18, 0.15)',
            fill: true,
            stepped: true,
            pointRadius: 4,
            pointBackgroundColor: '#1ED612',
            pointBorderColor: isDark ? '#18181b' : '#ffffff',
            pointBorderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: isDark ? '#27272a' : '#ffffff',
              titleColor: isDark ? '#fafafa' : '#010101',
              bodyColor: isDark ? '#a1a1aa' : '#71717a',
              borderColor: isDark ? '#3f3f46' : '#e4e4e7',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                label: (context: any) => `$${context.parsed.y.toFixed(0)}B`
              }
            }
          },
          scales: {
            x: {
              grid: { color: gridColor },
              ticks: { color: textColor }
            },
            y: {
              grid: { color: gridColor },
              ticks: {
                color: textColor,
                callback: (value: any) => `$${value}B`
              }
            }
          }
        }
      });
    }

    // Market Share Chart
    const topCompanies = [...companiesData]
      .sort((a: any, b: any) => (b.valuationManual || 0) - (a.valuationManual || 0))
      .slice(0, 10);

    const shareCtx = document.getElementById('market-share-chart') as HTMLCanvasElement;
    if (shareCtx) {
      new (window as any).Chart(shareCtx, {
        type: 'bar',
        data: {
          labels: topCompanies.map((c: any) => c.name),
          datasets: [{
            label: 'Valuation ($B)',
            data: topCompanies.map((c: any) => (c.valuationManual || 0) / 1e9),
            backgroundColor: topCompanies.map((c: any) =>
              c.type === 'public' ? '#1ED612' : 'rgba(255, 255, 255, 0.3)'
            ),
            borderColor: topCompanies.map((c: any) =>
              c.type === 'public' ? '#1ED612' : 'rgba(255, 255, 255, 0.5)'
            ),
            borderWidth: 1,
            borderRadius: 0
          }]
        },
        options: {
          indexAxis: 'y',
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: { display: false },
            tooltip: {
              backgroundColor: isDark ? '#27272a' : '#ffffff',
              titleColor: isDark ? '#fafafa' : '#010101',
              bodyColor: isDark ? '#a1a1aa' : '#71717a',
              borderColor: isDark ? '#3f3f46' : '#e4e4e7',
              borderWidth: 1,
              callbacks: {
                label: (context: any) => `$${context.parsed.x.toFixed(1)}B`
              }
            }
          },
          scales: {
            x: {
              grid: { color: gridColor },
              ticks: {
                color: textColor,
                callback: (value: any) => `$${value}B`
              }
            },
            y: {
              grid: { display: false },
              ticks: { color: textColor }
            }
          }
        }
      });
    }

    // Type Distribution Chart (Doughnut)
    const publicVal = companiesData
      .filter((c: any) => c.type === 'public' && c.valuationManual)
      .reduce((sum: number, c: any) => sum + (c.valuationManual || 0), 0) / 1e9;
    const privateVal = companiesData
      .filter((c: any) => c.type === 'private' && c.valuationManual)
      .reduce((sum: number, c: any) => sum + (c.valuationManual || 0), 0) / 1e9;

    const typeCtx = document.getElementById('type-distribution-chart') as HTMLCanvasElement;
    if (typeCtx) {
      new (window as any).Chart(typeCtx, {
        type: 'doughnut',
        data: {
          labels: ['Public Companies', 'Private Companies'],
          datasets: [{
            data: [publicVal, privateVal],
            backgroundColor: ['#1ED612', 'rgba(255, 255, 255, 0.3)'],
            borderColor: ['#1ED612', 'rgba(255, 255, 255, 0.5)'],
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: textColor,
                padding: 20,
                usePointStyle: true
              }
            },
            tooltip: {
              backgroundColor: isDark ? '#27272a' : '#ffffff',
              titleColor: isDark ? '#fafafa' : '#010101',
              bodyColor: isDark ? '#a1a1aa' : '#71717a',
              borderColor: isDark ? '#3f3f46' : '#e4e4e7',
              borderWidth: 1,
              callbacks: {
                label: (context: any) => `$${context.parsed.toFixed(1)}B`
              }
            }
          }
        }
      });
    }
  }

  document.addEventListener('DOMContentLoaded', initIndustryCharts);

  // Globe scroll effects
  function updateGlobeScrollEffects() {
    const scrollY = window.scrollY;
    const hero = document.querySelector('.industry-hero');
    const heroHeight = hero?.offsetHeight || 0;
    const headerHeight = 62;

    if (heroHeight > 0) {
      const transitionPoint = heroHeight - headerHeight;
      const scrollProgress = Math.min(Math.max(scrollY / transitionPoint, 0), 1);

      // Update globe overlay darkness
      document.documentElement.style.setProperty('--globe-darken', scrollProgress.toString());

      // Update hero text opacity
      const heroText = document.querySelector('.industry-hero .hero-text');
      if (heroText) {
        (heroText as HTMLElement).style.opacity = (1 - scrollProgress).toString();
      }
    }
  }

  updateGlobeScrollEffects();
  window.addEventListener('scroll', updateGlobeScrollEffects, { passive: true });
</script>

<style>
  /* Full-screen globe background */
  .globe-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 120%;
    z-index: -1;
    overflow: visible;
    background: var(--color-bg);
    padding-top: 10%;
    box-sizing: border-box;
  }

  .globe-background canvas {
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }

  .globe-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, calc(0.2 + var(--globe-darken, 0) * 0.8));
    pointer-events: none;
    transition: background 0.05s ease-out;
  }

  .globe-loading {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: var(--spacing-md);
    color: var(--color-text-muted);
    z-index: 1;
  }

  /* Page content */
  .page-content {
    position: relative;
    z-index: 1;
  }

  /* Industry hero - same height as homepage */
  .industry-hero {
    min-height: 85vh;
    display: flex;
    align-items: flex-end;
  }

  .industry-hero .hero-content {
    width: 100%;
    max-width: 1265px;
    margin: 0 auto;
    padding: 0 var(--spacing-lg);
    padding-bottom: calc(var(--spacing-2xl) * 1.7);
  }

  .industry-hero .hero-text {
    max-width: 600px;
    transition: opacity 0.05s ease-out;
  }

  /* Metrics Header - styled like table header */
  .metrics-header {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1px;
    background: var(--color-border);
    border-bottom: 1px solid var(--color-border);
  }

  .metric-item {
    background: var(--color-surface);
    padding: var(--spacing-xl) var(--spacing-lg);
    text-align: center;
  }

  [data-theme="dark"] .metric-item {
    background: rgba(1, 1, 1, 0.95);
  }

  .metric-item.highlight .metric-value {
    color: var(--color-primary);
  }

  .metric-value {
    display: block;
    font-size: 2rem;
    font-weight: 400;
    font-family: var(--font-mono);
    color: var(--color-text);
    margin-bottom: var(--spacing-xs);
  }

  .metric-value.positive {
    color: var(--color-primary);
  }

  .metric-value.negative {
    color: var(--color-negative);
  }

  .metric-label {
    font-size: 0.75rem;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Industry Charts Content */
  .industry-charts {
    padding: var(--spacing-2xl) var(--spacing-lg);
  }

  /* Chart Sections */
  .chart-section {
    margin-bottom: var(--spacing-2xl);
  }

  .section-header {
    margin-bottom: var(--spacing-lg);
  }

  .section-header h2 {
    font-size: 1.5rem;
    font-weight: 400;
    margin-bottom: var(--spacing-xs);
    letter-spacing: -0.02em;
  }

  .section-header p {
    color: var(--color-text-muted);
    font-size: 0.875rem;
  }

  .chart-container {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 0;
    padding: var(--spacing-xl);
    height: 350px;
  }

  .chart-container.large {
    height: 400px;
  }

  .chart-container.small {
    height: 300px;
    max-width: 500px;
  }

  /* Breakdown Section */
  .breakdown-section {
    margin-bottom: var(--spacing-2xl);
  }

  .breakdown-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--spacing-lg);
  }

  .breakdown-card {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 0;
    padding: var(--spacing-lg);
  }

  .breakdown-card h3 {
    font-size: 1rem;
    font-weight: 400;
    margin-bottom: var(--spacing-md);
    padding-bottom: var(--spacing-sm);
    border-bottom: 1px solid var(--color-border);
  }

  .breakdown-items {
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
  }

  .breakdown-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .breakdown-label {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    color: var(--color-text-secondary);
    font-size: 0.875rem;
  }

  .breakdown-value {
    font-weight: 400;
    font-family: var(--font-mono);
    color: var(--color-text);
  }

  .dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
  }

  .dot.public {
    background: var(--color-primary);
  }

  .dot.private {
    background: var(--color-text-muted);
  }

  /* Company Tooltip */
  .company-tooltip {
    position: fixed;
    z-index: 1000;
    pointer-events: none;
    opacity: 0;
    transform: translateY(5px);
    transition: opacity 0.2s, transform 0.2s;
  }

  .company-tooltip.visible {
    opacity: 1;
    transform: translateY(0);
  }

  .tooltip-content {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 0;
    padding: var(--spacing-md);
    box-shadow: var(--shadow-lg);
    min-width: 200px;
  }

  .tooltip-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
  }

  .tooltip-logo {
    width: 32px;
    height: 32px;
    border-radius: 0;
    background: var(--color-bg-secondary);
    object-fit: contain;
  }

  .tooltip-info h3 {
    font-size: 0.875rem;
    font-weight: 400;
    margin: 0;
  }

  .tooltip-info span {
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .tooltip-details {
    display: flex;
    flex-direction: column;
    gap: 2px;
    font-size: 0.75rem;
    color: var(--color-text-secondary);
    padding-top: var(--spacing-sm);
    border-top: 1px solid var(--color-border);
  }

  /* Responsive */
  @media (max-width: 1024px) {
    .metrics-header {
      grid-template-columns: repeat(2, 1fr);
    }

    .breakdown-grid {
      grid-template-columns: 1fr;
    }
  }

  @media (max-width: 768px) {
    .industry-charts {
      padding: var(--spacing-xl) var(--spacing-md);
    }

    .industry-hero .hero-content {
      padding: 0 var(--spacing-md);
      padding-bottom: calc(var(--spacing-2xl) * 1.7);
    }

    .metrics-header {
      grid-template-columns: 1fr 1fr;
    }

    .metric-item {
      padding: var(--spacing-md);
    }

    .metric-value {
      font-size: 1.5rem;
    }

    .chart-container {
      padding: var(--spacing-md);
      height: 300px;
    }

    .chart-container.large {
      height: 300px;
    }
  }
</style>
